---
title: 'Should you upgrade?'
metaTitle: 'Should you upgrade from Prisma 1 to Prisma 2.0?'
metaDescription: 'Learn whether you should already upgrade your Prisma 1 project to Prisma 2.0'
---

## Overview

This page helps you make an informated decision on when you should upgrade to Prisma 2.0.

## Main differences between Prisma 1 and Prisma 2.0

On a high-level, the biggest differences between Prisma 1 and Prisma 2.0 are the following:

- Prisma 2.0 doesn't require hosting a database proxy server (i.e., the [Prisma server](https://www.prisma.io/docs/1.34/prisma-server/)).
- Prisma 2.0 makes the features of Prisma 1 more modular and splits them into dedicated tools:
  - Prisma Client: An improved version of Prisma client 1.0
  - Prisma Migrate: Data modeling and migrations (formerly `prisma deploy`).
- Prisma 1 datamodel and `prisma.yml` have been merged into the [Prisma schema](../../reference/tools-and-interfaces/prisma-schema/prisma-schema-file).
- Prisma 2.0 uses its own [modeling language](https://github.com/prisma/specs/tree/master/schema) instead of being based on GraphQL SDL.
- Prisma 2.0 doesn't expose ["a GraphQL API for your database"](https://www.prisma.io/blog/prisma-and-graphql-mfl5y2r7t49c/) anymore, but only allows for _programmatic access_ via the Prisma Client API. This means Prisma 2.0 [doesn't support Prisma binding](https://www.prisma.io/docs/more/faq#does-prisma-client-support-graphql-schema-delegation-and-graphql-binding) any more.
- More powerful introspection allows connecting Prisma 2.0 to any existing database

## Feature parity

Prisma 2.0 doesn't have full feature parity with Prisma 1 yet. These are the biggest features that are still missing from Prisma 2.0:

- **Database migrations**: In Prisma 1, you could migrate your database schema using `prisma deploy`. Prisma 2.0 aims to bring back this functionality with [Prisma Migrate](../../reference/tools-and-interfaces/prisma-migrate). Until Prisma Migrate is available, you'll have to run your database migrations with plain SQL or another migration tool.
- **Realtime API (Subscriptions)**: Prisma 2.0 currently [doesn't have a way to subscribe to events happening in the database](https://github.com/prisma/prisma/issues/298) and get notified in realtime. It is currently unclear if, when and in what form a realtime API will be added to Prisma 2.0. For the time being, you can implement realtime functionality using native database triggers, or if you're using GraphQL subscriptions you can consider triggering subscriptions manually inside your _mutation resolvers_.
- **MongoDB support**: Prisma 2.0 [doesn't yet support MongoDB](https://github.com/prisma/prisma/issues/1277). If you're using Prisma 1 with MongoDB and want to upgrade to Prisma 2.0, you either need to migrate your data into a relational database first or wait until MongoDB is supported.

## Schema incompatibilities

The database schema that is created when running `prisma deploy` in Prisma 1 is only partially compatible with the one that Prisma 2.0 creates. This section gives an overview of the general incompatibilities and the potential workarounds.

| Feature                      | SQL Workaround | Prisma 2.0 Schema Workaround | Requires data migration |
| ---------------------------- | -------------- | ---------------------------- | ----------------------- |
| Default values               | Yes            | Yes                          | No                      |
| Generated CUIDs as ID values | No             | Yes                          | No                      |
| `@createdAt`                 | Yes            | Yes                          | No                      |
| `@updatedAt`                 | No             | Yes                          | No                      |
| 1-1 relations                | Yes            | No                           | No                      |
| Relation tables              | Yes            | No                           | Yes                     |
| Json type                    | Yes            | No                           | No                      |
| Enums                        | Yes            | No                           | Yes                     |
| Cascading deletes            | Depends        | No                           |                         |
| Scalar lists (arrays)        | Depends        | No                           |                         |

### Default values

#### Problem

When adding the `@default` directive in a Prisma 1 datamodel, the default values for this field are generated by the Prisma server at runtime. There's no `DEFAULT` constraint added to the database column.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
  published: Boolean @default(value: false)
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  published BOOLEAN NOT NULL
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id        String  @id
  published Boolean
}
```

Because the `DEFAULT` constraint has not been added to the database when mapping the Prisma 1 datamodel to the database with `prisma deploy`, Prisma 2.0 doesn't recognize it during introspection.

#### Workarounds

##### Manually add a `DEFAULT` constraint to the database column

You can alter the column to add the `DEFAULT` constraint as follows:

```sql
ALTER TABLE "Post"
	ALTER COLUMN published SET DEFAULT false;
```

After this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `published` field:

```prisma
model Post {
  id        String  @id
  published Boolean @default(false)
}
```

##### Manually add a `@default` attribute to the Prisma model

You can add the `@default` attribute to the Prisma model:

```prisma line-number
model Post {
  id        String
|  published Boolean @default(false)
}
```

If the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma server did in Prisma 1).

The main drawback of this approach is that after each re-introspection the `@default` attribute will be removed (because introspection overwrites the current Prisma schema) and you'll need to re-add it again.

### Generated CUIDs as ID values

#### Problem

Prisma 1 auto-generates ID values as CUIDs for `ID` fields when they're annotated with the `@id` directive. These CUIDs are generated by the Prisma server at runtime. Because this behaviour is not reflected in the database itself, the Prisma 2.0 introspection can't recognize it.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id String @id
}
```

Because there's no indication of the CUID behaviour in the database, Prisma's introspection doesn't recognize it.

#### Workaround

As a workaround, you can manually add the `@default(cuid())` attribute to the Prisma model:

```prisma line-number
model Post {
|  id String @id @default(cuid())
}
```

If the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma server did in Prisma 1).

Note that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!

### `@createdAt`

#### Problem

Prisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@createdAt` directive. These values are generated by the Prisma server at runtime. Because this behaviour is not reflected in the database itself, the Prisma 2.0 introspection can't recognize it.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
  createdAt: DateTime! @createdAt
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  "createdAt" TIMESTAMP NOT NULL
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id        String   @id
  createdAt DateTime
}
```

#### Workarounds

##### Manually add `DEFAULT CURRENT_TIMESTAMP` to the database column

You can alter the column to add the `DEFAULT` constraint as follows:

```sql
ALTER TABLE "Post"
	ALTER COLUMN "createdAt" SET DEFAULT CURRENT_TIMESTAMP;
```

After this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `published` field:

```prisma
model Post {
  id        String
  createdAt DateTime @default(now())
}
```

##### Manually add the `@default(now())` attribute to the Prisma model

As a workaround, you can manually add the `@default(now())` attribute to the Prisma model:

```prisma line-number
model Post {
  id        String    @id
|  createdAt DateTime @default(now())
}
```

If the `@default` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will generate the specified default values at runtime (similar to what the Prisma server did in Prisma 1).

Note that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!

### `@updatedAt`

#### Problem

Prisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@updatedAt` directive. These values are generated by the Prisma server at runtime. Because this behaviour is not reflected in the database itself, the Prisma 2.0 introspection can't recognize it.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  updatedAt TIMESTAMP
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id        String @id
  updatedAt DateTime
}
```

#### Workarounds

##### Manually add the `@updatedAt` attribute to the Prisma model

As a workaround, you can manually add the `@updatedAt` attribute to the Prisma model:

```prisma line-number
model Post {
  id        String   @id
|  updatedAt DateTime @updatedAt
}
```

If the `@updatedAt` attribute is set in the Prisma schema and you run `prisma generate`, the resulting Prisma Client code will automatically generate values for this column when an existing record is updated (similar to what the Prisma server did in Prisma 1).

Note that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!

### 1-1 relations in datamodel v1.1 with `link: INLINE`

#### Problem

In the [datamodel v1.1](https://www.prisma.io/blog/datamodel-v11-lrzqy1f56c90/) that was introduced in Prisma v1.31, 1-1 relations can be declared as _inline_. In that case, the relation will not be maintained via a [relation table](../../reference/tools-and-interfaces/prisma-schema/relations#relation-tables) but via a single foreign key on one of the two tables involved.

When this approach is used, Prisma doesn't add a `UNIQUE` constraint to the foreign key column which means that after Prisma 2.0 introspection, this former 1-1 relation will be added as a 1-n relation to the Prisma schema.

#### Example

##### Prisma 1.1 datamodel

```graphql
type User {
  id: ID! @id
  profile: Profile @relation(link: INLINE)
}

type Profile {
  id: ID! @id
  user: User
}
```

Note that omitting the `@relation` directive in this case would result in the same behaviour because `link: INLINE` is the _default_ for 1-1 relations.

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "User" (
  id VARCHAR(25) PRIMARY KEY NOT NULL
);

CREATE TABLE "Profile" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  "user" VARCHAR(25),
  FOREIGN KEY ("user") REFERENCES "User"(id)
);
```

##### Result of Prisma 2.0 introspection

```prisma
model User {
  id      String    @id
  Profile Profile[]
}

model Profile {
  id   String  @id
  user String?
  User User?   @relation(fields: [user], references: [id])
}
```

Because there's no `UNIQUE` constraint defined on the `userId` column (which represents the foreign key in this relation), Prisma's introspection recognizes the relation as 1-n.

#### Workarounds

##### Manually add `UNIQUE` constraint to the foreign key column

You can alter the foreign key column to add the `UNIQUE` constraint as follows:

```sql
ALTER TABLE "Profile"
  ADD CONSTRAINT userId_unique UNIQUE ("user");
```

After this adjustment, you can re-introspect your database and the 1-1 relation will be properly recognized:

```prisma
model User {
  id      String   @id
  Profile Profile?
}

model Profile {
  id   String  @id
  user String?
  User User?   @relation(fields: [userId], references: [id])
}
```

##### Manually remove the `[]` type modifier from the Prisma model

You can remove the `[]` type modifier attribute from the relation field in the Prisma schema:

```prisma line-number
model User {
  id      String  @id
|  Profile Profile
}

model Profile {
  id     String @id
  userId String
  User   User   @relation(fields: [userId], references: [id])
}
```

The main drawback of this approach is that after each re-introspection the `[]` type modifier will have to be removed again (because introspection overwrites the current Prisma schema) and you'll need to re-add it again.

### Relations that are represented via relation tables

#### Problem

All relations in the Prisma 1 datamodel v1.0 are represented as relation tables. In datamodel v1.1, all m-n relations as well as the 1-1 and 1-n relations declared as `link: TABLE` are represented as relation tables.

Because of this representation, Prisma 2.0 introspection will recognize all these relations as m-n relations.

#### Example

##### Prisma 1 datamodel

```graphql
type User {
  id: ID! @id
  posts: [Post!]!
}

type Post {
  id: ID! @id
  author: User! @relation(link: TABLE)
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "User" (
  id VARCHAR(25) PRIMARY KEY NOT NULL
);

CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL
);

CREATE TABLE "_PostToUser" (
  "A" VARCHAR(25) NOT NULL REFERENCES "Post"(id) ON DELETE CASCADE,
  "B" VARCHAR(25) NOT NULL REFERENCES "User"(id) ON DELETE CASCADE
);
CREATE UNIQUE INDEX "_PostToUser_AB_unique" ON "_PostToUser"("A" text_ops,"B" text_ops);
CREATE INDEX "_PostToUser_B" ON "_PostToUser"("B" text_ops);
```

##### Result of Prisma 2.0 introspection

```prisma
model User {
  id   String @id
  Post Post[] @relation(references: [id])
}

model Post {
  id   String @id
  User User[] @relation(references: [id])
}
```

Because the relation table that was created by Prisma 1 uses the same [conventions for relation tables](../../reference/tools-and-interfaces/prisma-schema/relations#conventions-for-relation-tables-in-implicit-m-n-relations) as Prisma 2.0, the relation now gets recognized as a m-n relation.

#### Workaround

As a workaround, you can migrate the data into a structure that's compatible with Prisma's 1-n relation:

1. Create new column `authorId` on the `Post` table. This column should be a _foreign key_ that references the `id` field of the `User` table.
1. Write a SQL query that reads all the rows from the `_PostToUser` relation table and for each row:
   1. Finds the respective `Post` record by looking up the value from column `A`
   1. Inserts the value from column `B` as the value for `authorId` into the `Post` record
1. Delete the `_PostToUser` relation table

After that you can introspect your database and the relation will now be recognized as 1-n.

### Json type

#### Problem

Prisma 1 supports the `Json` data type in its datamodel. However, in the underlying database, fields of type `Json` are actually stored as plain strings using the `TEXT` data type of the underlying database. Any parsing and validation of the stored JSON data is done by the Prisma server at runtime.

#### Example

##### Prisma 1 datamodel

```graphql
type User {
  id: ID! @id
  jsonData: Json
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "User" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  jsonData TEXT
);
```

##### Result of Prisma 2.0 introspection

```prisma
model User {
  id       String  @id
  jsonData String?
}
```

#### Workaround

You can manually change the type of the column to `JSON`

```sql
ALTER TABLE "User" ALTER COLUMN "jsonData" TYPE JSON;
```

After this adjustment, you can re-introspect your database and the field will now be recognized as `Json`:

```prisma line-number
model User {
  id       String @id
|  jsonData Json?
}
```

### Enums

#### Problem

Prisma 1 supports the `enum` data type in its datamodel. However, in the underlying database, types declared as `enum` are actually stored as plain strings using the `TEXT` data type of the underlying database. Any validation of the stored `enum` data is done by the Prisma server at runtime.

#### Example

##### Prisma 1 datamodel

```graphql
type User {
  id: ID! @id
  role: Role
}

enum Role {
  ADMIN
  CUSTOMER
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE "User" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  role TEXT
);
```

##### Result of Prisma 2.0 introspection

```prisma
model User {
  id   String  @id
  role String?
}
```

#### Workaround

You can manually turn the `role` column into an enum with your desired values:

1. Create an `enum` in your database that mirrors the `enum` you defined in the Prisma 1 datamodel:
    ```sql
    REATE TYPE "Role" AS ENUM ('CUSTOMER', 'ADMIN');
    ```
1. Change the type from `TEXT` to your new `enum`:
    ```sql
    ALTER TABLE "User" ALTER COLUMN "role" TYPE "Role"
    USING "role"::text::"Role";
    ```

After introspection, the type is now properly recognized as an enum:

```prisma
model User {
  id   String  @id
  role Role?
}

enum Role {
  ADMIN
  CUSTOMER
}
```

### Scalar lists

#### Problem

TBD

#### Example

TBD

#### Workaround

TBD

### Cascading deletes

#### Problem

TBD

#### Example

TBD

#### Workaround

TBD

## Prisma schema upgrade CLI

The [Prisma schema upgrade CLI](https://github.com/prisma/upgrade) helps you apply the workarounds that were explained in the [previous section](#schema-incompatibilities).

## Update strategies

There are two main upgrade strategies:

- **Upgrade all at once**: Entirely remove Prisma 1 from your project and move everything over to Prisma 2.0 at once
- **Gradual upgrade side-by-side**: Add Prisma 2.0 to the existing Prisma 1 project and gradually replace existing Prisma 1 features with Prisma 2.0 while running them side-by-side

### When to choose which strategy

If your project is not yet running in production or has little traffic and user data, the **all at once** strategy is recommended.

In case your project already sees a lot of traffic and has a lot of user data stored in the databse, you might want to consider the **gradual** upgrade strategy where you're running Prisma 1 and Prisma 2.0 side-by-side for a certain amount of time until you've replace all former Prisma 1 functionality with Prisma 2.0

### Upgrade path

No matter which of the strategies you choose, on a high-level the envisioned upgrade path looks as follows:

1. Install the new Prisma 2.0 CLI as a development dependency
1. Use the Prisma 2.0 CLI to introspect your Prisma 1 database and generate your Prisma schema
1. Run the [Prisma schema upgrade CLI]() to "fix" the Prisma schema
1. Install and generate Prisma Client 2.0
1. Adjust your application code, specifically replace the API calls from the Prisma client 1.0 with those of Prisma Client 2.0
