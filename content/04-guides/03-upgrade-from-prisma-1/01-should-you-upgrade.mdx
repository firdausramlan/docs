---
title: 'Should you upgrade?'
metaTitle: 'Should you upgrade from Prisma 1 to Prisma 2.0?'
metaDescription: 'Learn whether you should already upgrade your Prisma 1 project to Prisma 2.0'
---

## Overview

This page helps you make an informated decision on when you should upgrade to Prisma 2.0.

## Main differences between Prisma 1 and Prisma 2.0

On a high-level, the biggest differences between Prisma 1 and Prisma 2.0 are the following:

- Prisma 2.0 doesn't require hosting a database proxy server (i.e., the [Prisma server](https://www.prisma.io/docs/1.34/prisma-server/)).
- Prisma 2.0 makes the features of Prisma 1 more modular and splits them into dedicated tools:
  - Prisma Client: An improved version of Prisma client 1.0
  - Prisma Migrate: Data modeling and migrations (formerly `prisma deploy`).
- Prisma 1 datamodel and `prisma.yml` have been merged into the [Prisma schema](../../reference/tools-and-interfaces/prisma-schema/prisma-schema-file).
- Prisma 2.0 uses its own [modeling language](https://github.com/prisma/specs/tree/master/schema) instead of being based on GraphQL SDL.
- Prisma 2.0 doesn't expose ["a GraphQL API for your database"](https://www.prisma.io/blog/prisma-and-graphql-mfl5y2r7t49c/) anymore, but only allows for _programmatic access_ via the Prisma Client API. This means Prisma 2.0 [doesn't support Prisma binding](https://www.prisma.io/docs/more/faq#does-prisma-client-support-graphql-schema-delegation-and-graphql-binding) any more.
- More powerful introspection allows connecting Prisma 2.0 to any existing database

## Feature parity

Prisma 2.0 doesn't have full feature parity with Prisma 1 yet. These are the biggest features that are still missing from Prisma 2.0:

- **Database migrations**: In Prisma 1, you could migrate your database schema using `prisma deploy`. Prisma 2.0 aims to bring back this functionality with [Prisma Migrate](../../reference/tools-and-interfaces/prisma-migrate). Until Prisma Migrate is available, you'll have to run your database migrations with plain SQL or another migration tool.
- **Realtime API (Subscriptions)**: Prisma 2.0 currently [doesn't have a way to subscribe to events happening in the database](https://github.com/prisma/prisma/issues/298) and get notified in realtime. It is currently unclear if, when and in what form a realtime API will be added to Prisma 2.0. For the time being, you can implement realtime functionality using native database triggers, or if you're using GraphQL subscriptions you can consider triggering subscriptions manually inside your _mutation resolvers_.
- **MongoDB support**: Prisma 2.0 [doesn't yet support MongoDB](https://github.com/prisma/prisma/issues/1277). If you're using Prisma 1 with MongoDB and want to upgrade to Prisma 2.0, you either need to migrate your data into a relational database first or wait until MongoDB is supported.

## Schema incompatibilities

The database schema that is created when running `prisma deploy` in Prisma 1 is only partially compatible with the one that Prisma 2.0 creates. This section gives an overview of the general incompatibilities and the potential workarounds.

| Feature                      | SQL Workaround | Prisma 2.0 Schema Workaround | Compatible | 
| ---------------------------- | -------------- | ---------------------------- | ---------- | 
| Default values               | Yes            | Yes                          | Yes        | 
| Generated CUIDs as ID values | No             | Yes                          | Yes        | 
| `@createdAt`                 | Yes            | Yes                          | Yes        | 
| `@updatedAt`                 | No             | Yes                          | Yes        | 
| 1-1 relations                | Yes            | No                           | No         | 
| Relation tables              | Yes            | No                           | No         | 
| Cascading deletes            | Depends        | No                           | No         | 
| Scalar lists (arrays)        | Depends        | No                           | No         | 
| Json type                    | Yes            | No                           | No         | 
| Enums                        | Yes            | No                           | No         | 

### Default values

#### Problem

When adding the `@default` directive in a Prisma 1 datamodel, the default values for this field are generated by the Prisma server at runtime. There's no `DEFAULT` constraint added to the database column.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
  published: Boolean @default(value: false)
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE Post (
  id TEXT PRIMARY KEY NOT NULL,
  published BOOLEAN NOT NULL
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id        String
  published Boolean
}
```

Because the `DEFAULT` constraint has not been added to the database when mapping the Prisma 1 datamodel to the database with `prisma deploy`, Prisma 2.0 doesn't recognize it after introspection.

#### Workarounds

##### Manually add a `DEFAULT` constrain to the database column

You can alter the column to add the `DEFAULT` constraint as follows:

```sql
ALTER TABLE Post
  ADD CONSTRAINT published_false
  DEFAULT false FOR published;
```

After this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `published` field:

```prisma
model Post {
  id        String
  published Boolean @default(false)
}
```

##### Manually add a `@default` attribute to the Prisma model

You can add the `@default` attribute to the Prisma model:

```diff
model Post {
  id        String
+ published Boolean @default(false)
}
```

The main drawback of this approach is that after each re-introspection the `@default` attribute will be removed (because introspection overwrites the current Prisma schema) and you'll need to re-add it again.

### Generated CUIDs as ID values

#### Problem

Prisma 1 auto-generates ID values as CUIDs for `ID` fields when they're annotated with the `@id` directive. These CUIDs are generated by the Prisma server at runtime. Because this behaviour is not reflected in the database itself, the Prisma 2.0 introspection can't recognize it.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE Post (
  id TEXT PRIMARY KEY NOT NULL
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id String @id
}
```

Because there's no indication of the CUID behaviour in the database, Prisma's introspection doesn't recognize it.

#### Workarounds

As a workaround, you can manually add the `@default(cuid())` attribute to the Prisma model:

```diff
model Post {
+ id String @id @default(cuid())
}
```

Note that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!

### `@createdAt`

#### Problem

Prisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@createdAt` directive. These values are generated by the Prisma server at runtime. Because this behaviour is not reflected in the database itself, the Prisma 2.0 introspection can't recognize it.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
  createdAt: DateTime! @createdAt
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE Post {
  id TEXT PRIMARY KEY NOT NULL,
  createdAt TIMESTAMPZ
}
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id        String   @id
  createdAt DateTime
}
```

#### Workarounds

##### Manually add `DEFAULT CURRENT_TIMESTAMP` to the database column

You can alter the column to add the `DEFAULT` constraint as follows:

```sql
ALTER TABLE Post
  ADD CONSTRAINT created_at_now
  DEFAULT false FOR createdAt;
```

After this adjustment, you can re-introspect your database and the `@default` attribute will be added to the `published` field:

```prisma
model Post {
  id        String
  createdAt DateTime @default(now())
}
```

##### Manually add the `@default(now())` attribute to the Prisma model

As a workaround, you can manually add the `@default(now())` attribute to the Prisma model:

```diff
model Post {
  id        String    @id
+ createdAt DateTime @default(now())
}
```

Note that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!

### `@updatedAt`

#### Problem

Prisma 1 auto-generates values for `DateTime` fields when they're annotated with the `@updatedAt` directive. These values are generated by the Prisma server at runtime. Because this behaviour is not reflected in the database itself, the Prisma 2.0 introspection can't recognize it.

#### Example

##### Prisma 1 datamodel

```graphql
type Post {
  id: ID! @id
  updatedAt: DateTime! @updatedAt
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE Post (
  id TEXT PRIMARY KEY NOT NULL,
  updatedAt TIMESTAMPZ
);
```

##### Result of Prisma 2.0 introspection

```prisma
model Post {
  id        String @id
  updatedAt DateTime
}
```

#### Workarounds

##### Manually add the `@updatedAt` attribute to the Prisma model

As a workaround, you can manually add the `@updatedAt` attribute to the Prisma model:

```diff
model Post {
  id        String   @id
+ updatedAt DateTime @updatedAt
}
```

Note that you'll have to re-add the attribute after each introspection because introspection removes it (as the previous version of the Prisma schema is overwritten)!

### 1-1 relations in datamodel v1.1 with `link: INLINE`

#### Problem

In the [datamodel v1.1](https://www.prisma.io/blog/datamodel-v11-lrzqy1f56c90/) that was introduced in Prisma v1.31, 1-1 relations can be declared as _inline_. In that case, the relation will not be maintained via a relation table but via a single foreign key on one of the two tables involved.

When this approach is used, Prisma doesn't add a `UNIQUE` constraint to the foreign key column which means that after Prisma 2.0 introspection, this former 1-1 relation will be added as a 1-n relation to the Prisma schema.

#### Example

##### Prisma 1.1 datamodel

```graphql
type User {
  id: ID! @id
  profile: Profile @relation(link: INLINE)
}

type Profile {
  id: ID! @id
  user: User
}
```

Note that omitting the `@relation` directive in this case would result in the same behaviour because `link: INLINE` is the _default_ for 1-1 relations.

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE User (
  id TEXT PRIMARY KEY NOT NULL,
);

CREATE TABLE Profile (
  id TEXT PRIMARY KEY NOT NULL,
  userId TEXT,
  FOREIGN KEY id REFERENCES User(id)
);
```
##### Result of Prisma 2.0 introspection

```prisma
model User {
  id      String    @id
  Profile Profile[] 
}

model Profile {
  id     String @id  
  userId String
  User   User   @relation(fields: [userId], references: [id])
}
```

Because there's no `UNIQUE` constraint defined on the `userId` column (which represents the foreign key in this relation), Prisma's introspection recognizes the relation as 1-n.

#### Workarounds

##### Manually add `UNIQUE` constraint to the foreign key column

You can alter the foreign key column to add the `UNIQUE` constraint as follows:

```sql
ALTER TABLE Profile
  ADD CONSTRAINT userId_unique
  UNIQUE FOR userId;
```

After this adjustment, you can re-introspect your database and the 1-1 relation will be properly recognized:

```prisma
model User {
  id      String  @id
  Profile Profile
}

model Profile {
  id     String @id  
  userId String
  User   User   @relation(fields: [userId], references: [id])
}
```

##### Manually remove the `[]` type modifier from the Prisma model

You can remove the `[]` type modifier attribute from the relation field in the Prisma schema:

```diff
model User {
  id      String  @id
+ Profile Profile
}

model Profile {
  id     String @id  
  userId String
  User   User   @relation(fields: [userId], references: [id])
}
```

The main drawback of this approach is that after each re-introspection the `[]` type modifier will have to be removed again (because introspection overwrites the current Prisma schema).

### Relations that are represented via relation tables

#### Problem

All relations in the Prisma 1 datamodel v1.0 are represented as relation tables. In the datamodel v1.1 version, all m-n relations as well as the 1-1 and 1-n relations declared as `link: TABLE` are represented as relation tables.

Because of this representation, Prisma 2.0 introspection will recognize all these relations as m-n relations.

#### Example

##### Prisma 1 datamodel

```graphql
type User {
  id: ID! @id
  profile: Profile @relation(link: TABLE)
}

type Profile {
  id: ID! @id
  user: User
}
```

##### Prisma 1 generated SQL migration

```sql
CREATE TABLE User (
  id TEXT PRIMARY KEY NOT NULL
);

CREATE TABLE Profile (
  id TEXT PRIMARY KEY NOT NULL
);

-- TBD: add relation table
```

#### Workaround

### Cascading deletes

#### Problem


<!-- ## Upgrade paths

Based on these differences, the high-level steps to upgrade a project from using Prisma 1 are as follows:

1. Install the new Prisma 2.0 CLI as a development dependency
1. Use the Prisma 2.0 CLI to introspect your Prisma 1 database and generate your Prisma schema
1. Install and generate Prisma Client 2.0
1. Adjust your application code, specifically replace the API calls from the Prisma client 1.0 with those of Prisma Client 2.0

**Note that steps 3. and 4. will look somewhat different if you are:**

- **not using the Prisma client** (e.g. because you're using Prisma bindings).
- **building a GraphQL API using `nexus-prisma`**.

Both scenarios will be covered in other upgrade guides that are [coming soon](https://github.com/prisma/prisma/issues/1937).

In this guide, we'll take a look at migrating a REST API from Prisma 1 to Prisma 2.0 based on this [Prisma 1 example](https://github.com/prisma/prisma1-examples/tree/master/typescript/rest-express). -->


## Prisma schema upgrade CLI

The [Prisma schema upgrade CLI](https://github.com/prisma/upgrade) helps you apply the workarounds that were explained in the [previous section](#schema-incompatibilities).

## Update strategies

There are two main upgrade strategies:

- **Upgrade all at once**: Entirely remove Prisma 1 from your project and move everything over to Prisma 2.0 at once
- **Gradual upgrade side-by-side**: Add Prisma 2.0 to the existing Prisma 1 project and gradually replace existing Prisma 1 features with Prisma 2.0 while running them side-by-side

### When to choose which strategy

If your project is not yet running in production or has little traffic and user data, the **all at once** strategy is recommended.

In case your project already sees a lot of traffic and has a lot of user data stored in the databse, you might want to consider the **gradual** upgrade strategy where you're running Prisma 1 and Prisma 2.0 side-by-side for a certain amount of time until you've replace all former Prisma 1 functionality with Prisma 2.0


